     type lptr = ^item; { указатель на элемент списка }
          item = record    { элемент списка }
            key : integer; { ключ }
            inf : data;    { данные }
            next: lptr;    { указатель на элемент списка }
            end;

Пример 6 демонстрирует сортировку выборкой. Указатель newh является указателем 
на начало выходного списка, исходно - пустого. Во входном списке ищется 
максимальный элемент. Найденный элемент исключается из входного списка и 
включается в начало выходного списка. Работа алгоритма заканчивается, когда 
входной список станет пустым. Обратим внимание читателя на несколько 
особенностей алгоритма. Во-первых, во входном списке ищется всякий раз не 
минимальный, а максимальный элемент. Поскольку элемент включается в начало 
выходного списка, элементы с большими ключами оттесняются к концу выходного 
списка и последний, таким образом, оказывается отсортированным по возрастанию 
ключей. Во-вторых, при поиске во входном списке сохраняется не только адрес 
найденного элемента в списке, но и адрес предшествующего ему в списке элемента - 
это впоследствии облегчает исключение элемента из списка (вспомните пример 1). 
В-третьих, обратите внимание на то, что у нас не возникает никаких проблем с 
пропуском во входном списке тех элементов, которые уже выбраны - они просто 
исключены из входной структуры данных.

{==== Программный пример 6 ====}
 { Сортировка выборкой на 1-связном списке }
 Function Sort(head : lptr) : lptr;
  var newh, max, prev, pmax, cur : lptr;
   begin        newh:=nil;         { выходной список - пустой }
   while head<>nil do { цикл, пока не опустеет входной список }
     begin   max:=head; prev:=head; { нач.максимум - 1-й эл-т }
     cur:=head^.next;     { поиск максимума во входном списке }
     while cur<>nil do begin
       if cur^.key>max^.key then begin
{ запоминается адрес максимума и адрес предыдущего эл-та }
         max:=cur; pmax:=prev;
     end;    prev:=cur; cur:=cur^.next; { движение по списку }
       end;        { исключение максимума из входного списка }
     if max=head then head:=head^.next
     else pmax^.next:=max^.next;
     { вставка в начало выходного списка }
     max^.next:=newh; newh:=max;
   end;  Sort:=newh;
  end;


В программном примере 7 - иллюстрации сортировки вставками - из входного списка 
выбирается (и исключается) первый элемент и вставляется в выходной список "на 
свое место" в соответствии со значениями ключей. Обратите внимание на то, что в 
двух последних примерах пересылок данных не происходит, все записи таблиц 
остаются на своих местах в памяти, меняются только связи между ними - указатели.


{==== Программный пример 7 ====}
{ Сортировка вставками на 1-связном списке }
type data = integer;
Function Sort(head : lptr) : lptr;
var newh, cur, sel : lptr;
begin
newh:=nil; { выходной список - пустой }
while head <> nil do begin { цикл, пока не опустеет входной список }
sel:=head; { эл-т, который переносится в выходной список }
head:=head^.next; { продвижение во входном списке }
if (newh=nil) or (sel^.key < newh^.key) then begin
{выходной список пустой или элемент меньше 1-го-вставка в начало}
sel^.next:=newh; newh:=sel; end
else begin { вставка в середину или в конец }
cur:=newh;
{ до конца выходного списка или пока ключ следующего эл-та не будет
больше вставляемого }
while (cur^.next <> nil) and (cur^.next^.key < sel^.key) do
cur:=cur^.next;
{ вставка в выходной список после эл-та cur }
sel^.next:=cur^.next; cur^.next:=sel;
end; end; Sort:=newh;
end;