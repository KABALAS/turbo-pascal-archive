 Юнит содержит класс TParsedFunction и описания типов, необходимых для
 работы с ним.

 Класс TParsedFunction (PF) является интерпретатором (парсером) функций.
 Метод ParseFunction позволяет распознать любое математическое выражение,
 содержащее (опционально) x, y, z, различные мат. функции и численные
 константы (см. список ниже), записанное в виде строки. Распознанное выражение
 записывается особым образом в виде 4 массивов переменных. При этом метод
 содержит параметр ErCode, позволяющий определить, успешно ли прошла операция
 распознавания:
   ErCode =
     0 - Операция прошла успешно
     1 - Встречена неизвестная функция или оператор
     2 - В выражении содержится неравное количество открывающихся и
         закрывающихся скобок
     3 - Обнаружен недопустимый символ
         (допустимыми являются: лат буквы любого регистра, цифры, круглые
          скобки, пробел, символы + - * / ^ и точка.)

 Метод Compute позволяет вычислить значение ранее распознанной функции для
 заданных значений x, y и z (если параметр опущен, он считается равным 0).

 Методы ImportParsed и ExportParsed позволяют импортировать/экспортировать
 распознанные функции в види запаси типа TPFRecord.

 Принцип и алгоритм работы парсера:
 Рассмотрим следующее выражение (в качестве примера):

 (5+у)*sin(x^3)+х

 Это выражение можно записать как а1 = а2 + а3,
 где а2 = (5+у)*sin(x^3), а а3 = х.
 В свою очередь, а2 = а4*а5, где а4 = 5+у, а а5 = sin(х^3)...
 И так далее. В конце концов мы получим цепочку простейших операций
 над двумя или одним операндом, каждый из которых может быть либо
 числом/переменной, либо другой парой операндов.
 Цепочка технически записывается тремя массивами: одномерным массивом,
 содержащим указание на операцию (в моем юните каждая операция обозначена
 номером и хранится в типе byte - вряд ли вы придумаете более 255 операций :)
 Я лично вспомнил только 23 :)). Второй массив является двухмерным и
 хранит ссылки на участывующие в операции операнды. Ссылки представляют
 собой номера звеньев цепи и хранятся в типе word.
 Третий массив содержит переменные, числовые константы и числа, обнаруженные
 в выражении. Этот массив связан двумя первыми операций присвоения, которая
 у меня имеет номер 0. В этом случае номер первого операнда ссылается не на
 элемент массива операндов, а на элемент этого тертьего массива.
 Как видите, все просто!
 Чтобы подсчитать значение выражения, необходимо ввести еще один массив
 (у меня обозначен как а). Заметьте, что операнды, участвующие в каждой
 операции, всегда имеют номер больше, чем у этого операнда. Поэтому, чтобы
 вычислить значение самого выражения (т.е. элемента а1), достаточно
 подсчитать значение каждого элемента а, начиная с конца массива.


 Скорость вычисления:
 Благодаря тому, что распознавание функции производится только 1 раз,
 а вся операция вычисления по сути сводится к действиям над массивами,
 удается достичь скорости вычисления, сравнимой со скоростью вычисления
 того же выражения самим компилятором Дельфи.
 Сами скорости вычисления различаются в зависимости от сложности выражения
 (иногда скорость вычислений парсера получается даже выше, чем у компилятора!
  Это вызвано определенной оптимизацие выражения при парсинге), но в среднем
  время вычислений парсера составляет 150-200% времени вычислений компилятора.

  Точность вычислений:
  Информация хранится в типе Single. В большей точности нет смысла, псокольку
  в строке действительные числа передаются с очевидной погрешностью. В любом
  случае, чтобы добиться большей точности, необходимо просто поменять single на
  нужный тип, везде, где он встречается.
  Точность вычислений в среднем составляет е-5

  Формат представления строки:
  - Длина строки ограничена 255 символами
    (ограничение можно снять, заменив shortString на ansiString в
    определении метода)
  - Регистр букв НЕВАЖЕН
  - Разрешается использовать пробелы
  - Десятичная часть должна быть отделена точкой (а не запятой)
  - Выражение должно быть записано по обычным правилам записи мат. выражений
    для компьютера. (Например: x^2 + sin(5*y)/exp(4*z) )
  - Программа учитывает приоритет действий (в порядке убывания: вычисление
    функций, взятие в степень, умножение и деление, сложение и вычитание)
  - Программа учитывает скобки
  - Программа знает следующие мат. операции:
      + : сложение
      - : вычитание
      / : деление
      * : умножение
      ^ : возведение в произвольную степень
  - Программа знает следующие мат. функции:
      sin     - синус
      cos     - косинус
      tan     - тангенс
      cot     - котангенс
      exp     - экспонента
      ln      - нат. логарифм
      sqr     - квадрат
      sqrt    - квадратный корень
      round   - округление
      trunc   - целая часть
      asin    - арксинус
      acos    - арккосинус
      atan    - арктангенс
      acot    - арккотангенс
      sinh    - гип. синус
      cosh    - гип. косинус
      tanh    - гип. тангенс
      coth    - гип. котангенс

  - Программа знает следующие числовые константы:
      pi  - число пи
      e   - число е

  - Программа понимает функции вплоть до 3 переменных.
    Переменные обозначаются буквами x, y, z

  - Программа понимает только числа, представленные в
    десятином виде

   Примечание (емкость массивов)
   Требуемая емкость массива определяется как сумма:
   кол-во операторов(функций) + кол-во вхождений величин + 2.
   Например:  5*sin(x^3)+х
   4 оператора (умножение, синус, сложение, возведение в степень)
   +
   4 вхождения величин (5, 3, х, х)
   +
   2 = 10.
   Автору представляется, что емкости 100 должно хватить для записи
   весьма сложного выражения. В любом случае емкость можно увеличить
   изменением константы Capacity.
   (Изначально в программе использовались динамические массивы,
   но затем от них пришлось отказаться - слишком много геммороя :) )

   !WARNINGS!

  Необходимо самостоятельно контролировать следующие вещи:
  - Обращение к методу Compute для нераспознанной функции вызовет
    ошибку времени исполнения
  - Превышение возможной емкости массивов также, разумеется, вызовет ошибку.
    Подгоните значение Capacity под собственные нужды.
  - Ошибки типа деления на ноль, которые могут быть в выражении, лежат
    полностью на совести пользователя  

   ЛИЦЕНЗИЯ:
   Данный юнит и представленные в нем классы и методы, а также алгоритм
   распознавания функций являются интеллектуальной собственностью
   ЩЕГЛОВА ИЛЬИ АЛЕКСАНДРОВИЧА <franzy@comail.ru>.
   Данные класс, его методы и алгоритм распространяются бесплатно для
   некоммерческого использования. Какое-либо другое распространение
   указанной информации с целью получения выгоды запрещено. Использование
   класса, его методов или алгоритма распознавания в программах,
   распространяемых комерческим путем, возможно только с письменного
   разрешения названного выше владельца авторского права.

   Данная информация должна быть указана в теле любой программы, использующей
   алгоритм распознавания, класс или его методы.

   Благодарности:
   Юрию Лапухову за помощь в обнаружении ошибок в алгоритме